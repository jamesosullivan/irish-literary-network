import { rectIntersect } from './helper.js';
import { LEFT_RIGHT_PADDING, TOP_BOTTOM_PADDING } from './variables.js';
import * as s from './styles.js';
export class CssLabel {
    constructor(container, text) {
        this.element = document.createElement('div');
        this.fontWidthHeightRatio = 0.6;
        this.fontSize = 14;
        this.x = 0;
        this.y = 0;
        this.estimatedWidth = 0;
        this.estimatedHeight = 0;
        this.visible = false;
        this.prevVisible = false;
        this.weight = 0;
        this.color = 'white';
        this.shouldBeShown = false;
        this.text = '';
        this.opacity = 0;
        this.padding = {
            left: LEFT_RIGHT_PADDING,
            top: TOP_BOTTOM_PADDING,
            right: LEFT_RIGHT_PADDING,
            bottom: TOP_BOTTOM_PADDING,
        };
        this.pointerEvents = 'all';
        this.container = container;
        this.element.className = s.pointLabel(this.padding, this.pointerEvents);
        if (text)
            this.setText(text);
    }
    setText(text) {
        if (this.text !== text) {
            this.text = text;
            this.element.innerHTML = text;
            this.measureText();
        }
    }
    setPosition(x, y) {
        this.x = x;
        this.y = y;
    }
    setFontSize(fontSize) {
        if (this.fontSize !== fontSize) {
            this.fontSize = fontSize;
            this.measureText();
        }
    }
    setColor(color) {
        if (this.color !== color)
            this.element.style.color = color;
        this.color = color;
    }
    resetColor() {
        this.element.style.removeProperty('color');
    }
    setOpacity(opacity) {
        const isVisible = this.getVisibility();
        if (isVisible && this.opacity !== opacity) {
            this.element.style.opacity = String(opacity);
        }
        this.opacity = opacity;
    }
    setForceShow(shouldBeShown) {
        this.shouldBeShown = shouldBeShown;
    }
    getForceShow() {
        return this.shouldBeShown;
    }
    draw() {
        const isVisible = this.getVisibility();
        if (isVisible !== this.prevVisible) {
            if (this.prevVisible === false) {
                this.container.appendChild(this.element);
                window.requestAnimationFrame(() => { this.element.style.opacity = String(this.opacity); });
            }
            else {
                this.container.removeChild(this.element);
                this.element.style.opacity = '0';
            }
            this.prevVisible = isVisible;
        }
        if (isVisible) {
            this.element.style.transform = `
        translate(-50%, -100%)
        translate3d(${this.x}px, ${this.y}px, 0)
      `;
        }
    }
    overlaps(label) {
        return rectIntersect({
            height: this.estimatedHeight,
            width: this.estimatedWidth,
            x: this.x,
            y: this.y,
        }, {
            height: label.estimatedHeight,
            width: label.estimatedWidth,
            x: label.x,
            y: label.y,
        });
    }
    setVisibility(visible = true) {
        this.visible = visible;
    }
    getVisibility() {
        return this.visible;
    }
    isOnScreen() {
        return this.x > 0 && this.y > 0 && this.x < this.container.offsetWidth && this.y < this.container.offsetHeight;
    }
    setWeight(weight) {
        this.weight = weight;
    }
    getWeight() {
        return this.weight;
    }
    setPadding(padding) {
        if (this.padding.left !== padding.left ||
            this.padding.top !== padding.top ||
            this.padding.right !== padding.right ||
            this.padding.bottom !== padding.bottom) {
            this.padding = padding;
            this.element.className = s.pointLabel(this.padding, this.pointerEvents);
        }
    }
    setPointerEvents(pointerEvents) {
        if (this.pointerEvents !== pointerEvents) {
            this.pointerEvents = pointerEvents;
            this.element.className = s.pointLabel(this.padding, this.pointerEvents);
        }
    }
    raise() {
        this.container.appendChild(this.element);
    }
    destroy() {
        this.element.remove();
    }
    measureText() {
        this.estimatedWidth = this.fontSize * this.fontWidthHeightRatio * this.element.innerHTML.length + this.padding.left + this.padding.right;
        this.estimatedHeight = this.fontSize + this.padding.top + this.padding.bottom;
    }
}
//# sourceMappingURL=css-label.js.map