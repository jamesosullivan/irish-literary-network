import { CssLabel } from './css-label.js';
import * as s from './styles.js';
export class LabelRenderer {
    constructor(container, options) {
        this.cssLabels = new Map();
        this.pointerEvents = 'all';
        this.elementToData = new Map();
        this.container = container;
        container.addEventListener('click', (e) => {
            var _a;
            const label = this.elementToData.get(e.target);
            if (label) {
                (_a = this.onClickCallback) === null || _a === void 0 ? void 0 : _a.call(this, e, label);
            }
        });
        this.container.className = `${s.labelsContainer}`;
        if (options === null || options === void 0 ? void 0 : options.onLabelClick)
            this.onClickCallback = options.onLabelClick;
        if (options === null || options === void 0 ? void 0 : options.padding)
            this.padding = options.padding;
        if (options === null || options === void 0 ? void 0 : options.pointerEvents)
            this.pointerEvents = options.pointerEvents;
    }
    setLabels(labels) {
        // Add new labels and take into account existing labels
        const labelsToDelete = new Map(this.cssLabels);
        labels.forEach(label => {
            const { x, y, fontSize, color, text, weight, opacity, shouldBeShown } = label;
            const exists = labelsToDelete.get(label.id);
            if (exists) {
                labelsToDelete.delete(label.id);
            }
            else {
                const cssLabel = new CssLabel(this.container, label.text);
                this.cssLabels.set(label.id, cssLabel);
                this.elementToData.set(cssLabel.element, label);
            }
            const labelToUpdate = this.cssLabels.get(label.id);
            if (labelToUpdate) {
                labelToUpdate.setText(text);
                labelToUpdate.setPosition(x, y);
                if (weight !== undefined)
                    labelToUpdate.setWeight(weight);
                if (fontSize !== undefined)
                    labelToUpdate.setFontSize(fontSize);
                if (color !== undefined)
                    labelToUpdate.setColor(color);
                if (this.padding !== undefined)
                    labelToUpdate.setPadding(this.padding);
                if (this.pointerEvents !== undefined)
                    labelToUpdate.setPointerEvents(this.pointerEvents);
                if (opacity !== undefined)
                    labelToUpdate.setOpacity(opacity);
                if (shouldBeShown !== undefined)
                    labelToUpdate.setForceShow(shouldBeShown);
            }
        });
        // Remove labels from points that don't longer exist
        for (const [key] of labelsToDelete) {
            const cssLabel = this.cssLabels.get(key);
            if (cssLabel) {
                this.elementToData.delete(cssLabel.element);
                cssLabel.destroy();
            }
            this.cssLabels.delete(key);
        }
    }
    draw(withIntersection = true) {
        if (withIntersection)
            this.intersectLabels();
        this.cssLabels.forEach(cssLabel => cssLabel.draw());
    }
    show() {
        this.container.className = `${s.labelsContainer}`;
    }
    hide() {
        this.container.className = `${s.labelsContainer} ${s.hidden}`;
    }
    destroy() {
        this.cssLabels.forEach(cssLabel => cssLabel.destroy());
    }
    intersectLabels() {
        const cssLabels = Array.from(this.cssLabels.values());
        cssLabels.forEach(l => l.setVisibility(l.isOnScreen()));
        for (let i = 0; i < cssLabels.length; i += 1) {
            const label1 = cssLabels[i];
            if (!label1.getVisibility())
                continue;
            for (let j = i + 1; j < cssLabels.length; j += 1) {
                const label2 = cssLabels[j];
                if (!label2.getVisibility())
                    continue;
                const isOverlapping = label1.overlaps(label2);
                if (isOverlapping) {
                    if (label2.getWeight() > label1.getWeight()) {
                        label1.setVisibility(label2.getForceShow() ? false : label1.getForceShow());
                    }
                    else {
                        label2.setVisibility(label1.getForceShow() ? false : label2.getForceShow());
                    }
                    continue;
                }
            }
        }
    }
}
export { CssLabel };
//# sourceMappingURL=index.js.map