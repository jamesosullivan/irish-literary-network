import { rectIntersect } from './helper.js'
import { LEFT_RIGHT_PADDING, TOP_BOTTOM_PADDING } from './variables.js'
import { Padding, Options } from './types.js'

import * as s from './styles.js'

export class CssLabel {
  public element: HTMLDivElement = document.createElement('div')
  public readonly fontWidthHeightRatio = 0.6
  private fontSize = 14
  private container: HTMLDivElement
  private x = 0
  private y = 0
  private estimatedWidth = 0
  private estimatedHeight = 0
  private visible = false
  private prevVisible = false
  private weight = 0
  private color = 'white'
  private shouldBeShown = false
  private text = ''
  private opacity = 0
  private padding: Padding = {
    left: LEFT_RIGHT_PADDING,
    top: TOP_BOTTOM_PADDING,
    right: LEFT_RIGHT_PADDING,
    bottom: TOP_BOTTOM_PADDING,
  }

  private pointerEvents: Options['pointerEvents'] = 'all'

  public constructor (container: HTMLDivElement, text?: string) {
    this.container = container
    this.element.className = s.pointLabel(this.padding, this.pointerEvents)
    if (text) this.setText(text)
  }

  public setText (text: string): void {
    if (this.text !== text) {
      this.text = text
      this.element.innerHTML = text
      this.measureText()
    }
  }

  public setPosition (x: number, y: number): void {
    this.x = x
    this.y = y
  }

  public setFontSize (fontSize: number): void {
    if (this.fontSize !== fontSize) {
      this.fontSize = fontSize
      this.measureText()
    }
  }

  public setColor (color: string): void {
    if (this.color !== color) this.element.style.color = color
    this.color = color
  }

  public resetColor (): void {
    this.element.style.removeProperty('color')
  }

  public setOpacity (opacity: number): void {
    const isVisible = this.getVisibility()
    if (isVisible && this.opacity !== opacity) {
      this.element.style.opacity = String(opacity)
    }
    this.opacity = opacity
  }

  public setForceShow (shouldBeShown: boolean): void {
    this.shouldBeShown = shouldBeShown
  }

  public getForceShow (): boolean {
    return this.shouldBeShown
  }

  public draw (): void {
    const isVisible = this.getVisibility()
    if (isVisible !== this.prevVisible) {
      if (this.prevVisible === false) {
        this.container.appendChild(this.element)
        window.requestAnimationFrame(() => { this.element.style.opacity = String(this.opacity) })
      } else {
        this.container.removeChild(this.element)
        this.element.style.opacity = '0'
      }
      this.prevVisible = isVisible
    }

    if (isVisible) {
      this.element.style.transform = `
        translate(-50%, -100%)
        translate3d(${this.x}px, ${this.y}px, 0)
      `
    }
  }

  public overlaps (label: CssLabel): boolean {
    return rectIntersect({
      height: this.estimatedHeight,
      width: this.estimatedWidth,
      x: this.x,
      y: this.y,
    }, {
      height: label.estimatedHeight,
      width: label.estimatedWidth,
      x: label.x,
      y: label.y,
    })
  }

  public setVisibility (visible = true): void {
    this.visible = visible
  }

  public getVisibility (): boolean {
    return this.visible
  }

  public isOnScreen (): boolean {
    return this.x > 0 && this.y > 0 && this.x < this.container.offsetWidth && this.y < this.container.offsetHeight
  }

  public setWeight (weight: number): void {
    this.weight = weight
  }

  public getWeight (): number {
    return this.weight
  }

  public setPadding (padding: Padding): void {
    if (this.padding.left !== padding.left ||
        this.padding.top !== padding.top ||
        this.padding.right !== padding.right ||
        this.padding.bottom !== padding.bottom) {
      this.padding = padding
      this.element.className = s.pointLabel(this.padding, this.pointerEvents)
    }
  }

  public setPointerEvents (pointerEvents: Options['pointerEvents']): void {
    if (this.pointerEvents !== pointerEvents) {
      this.pointerEvents = pointerEvents
      this.element.className = s.pointLabel(this.padding, this.pointerEvents)
    }
  }

  public raise (): void {
    this.container.appendChild(this.element)
  }

  public destroy (): void {
    this.element.remove()
  }

  private measureText (): void {
    this.estimatedWidth = this.fontSize * this.fontWidthHeightRatio * this.element.innerHTML.length + this.padding.left + this.padding.right
    this.estimatedHeight = this.fontSize + this.padding.top + this.padding.bottom
  }
}
