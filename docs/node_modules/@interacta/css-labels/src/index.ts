import { CssLabel } from './css-label.js'
import { LabelOptions, OnClickCallback, Options, Padding } from './types.js'

import * as s from './styles.js'

export class LabelRenderer {
  private cssLabels = new Map<string, CssLabel>()
  private container: HTMLDivElement
  private onClickCallback: OnClickCallback | undefined
  private padding: Padding | undefined
  private pointerEvents: Options['pointerEvents'] = 'all'
  private elementToData = new Map<HTMLDivElement, LabelOptions>()

  public constructor (container: HTMLDivElement, options?: Options) {
    this.container = container
    container.addEventListener('click', (e) => {
      const label = this.elementToData.get(e.target as HTMLDivElement)
      if (label) {
        this.onClickCallback?.(e, label)
      }
    })
    this.container.className = `${s.labelsContainer}`
    if (options?.onLabelClick) this.onClickCallback = options.onLabelClick
    if (options?.padding) this.padding = options.padding
    if (options?.pointerEvents) this.pointerEvents = options.pointerEvents
  }

  public setLabels (labels: LabelOptions[]): void {
    // Add new labels and take into account existing labels
    const labelsToDelete = new Map(this.cssLabels)
    labels.forEach(label => {
      const { x, y, fontSize, color, text, weight, opacity, shouldBeShown } = label
      const exists = labelsToDelete.get(label.id)
      if (exists) {
        labelsToDelete.delete(label.id)
      } else {
        const cssLabel = new CssLabel(this.container, label.text)
        this.cssLabels.set(label.id, cssLabel)
        this.elementToData.set(cssLabel.element, label)
      }
      const labelToUpdate = this.cssLabels.get(label.id)
      if (labelToUpdate) {
        labelToUpdate.setText(text)
        labelToUpdate.setPosition(x, y)
        if (weight !== undefined) labelToUpdate.setWeight(weight)
        if (fontSize !== undefined) labelToUpdate.setFontSize(fontSize)
        if (color !== undefined) labelToUpdate.setColor(color)
        if (this.padding !== undefined) labelToUpdate.setPadding(this.padding)
        if (this.pointerEvents !== undefined) labelToUpdate.setPointerEvents(this.pointerEvents)
        if (opacity !== undefined) labelToUpdate.setOpacity(opacity)
        if (shouldBeShown !== undefined) labelToUpdate.setForceShow(shouldBeShown)
      }
    })

    // Remove labels from points that don't longer exist
    for (const [key] of labelsToDelete) {
      const cssLabel = this.cssLabels.get(key)
      if (cssLabel) {
        this.elementToData.delete(cssLabel.element)
        cssLabel.destroy()
      }
      this.cssLabels.delete(key)
    }
  }

  public draw (withIntersection = true): void {
    if (withIntersection) this.intersectLabels()
    this.cssLabels.forEach(cssLabel => cssLabel.draw())
  }

  public show (): void {
    this.container.className = `${s.labelsContainer}`
  }

  public hide (): void {
    this.container.className = `${s.labelsContainer} ${s.hidden}`
  }

  public destroy (): void {
    this.cssLabels.forEach(cssLabel => cssLabel.destroy())
  }

  private intersectLabels (): void {
    const cssLabels = Array.from(this.cssLabels.values())
    cssLabels.forEach(l => l.setVisibility(l.isOnScreen()))
    for (let i = 0; i < cssLabels.length; i += 1) {
      const label1 = cssLabels[i] as CssLabel
      if (!label1.getVisibility()) continue

      for (let j = i + 1; j < cssLabels.length; j += 1) {
        const label2 = cssLabels[j] as CssLabel
        if (!label2.getVisibility()) continue

        const isOverlapping = label1.overlaps(label2)
        if (isOverlapping) {
          if (label2.getWeight() > label1.getWeight()) {
            label1.setVisibility(label2.getForceShow() ? false : label1.getForceShow())
          } else {
            label2.setVisibility(label1.getForceShow() ? false : label2.getForceShow())
          }
          continue
        }
      }
    }
  }
}

export { CssLabel }
export type { LabelOptions }
